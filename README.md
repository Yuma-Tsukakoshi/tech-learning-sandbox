# 技術習得のための学習ロードマップ

新たな知識をチャンク化し、実装スキルを向上させるための学習ロードマップ

## 1. 学習項目の分類

### A. コア・バックエンド技術
基本的なサーバーサイドの実装技術です。多くのアーキテクチャの基礎となります。
- Goルーチンを用いた並列処理
- メッセージキューを用いた非同期処理 (RabbitMQ/SQS)
- 高度なキャッシュ戦略 (Redis)
- gRPCを用いたAPIリクエスト処理
- GraphQL

### B. フロントエンド技術
ユーザーインターフェースと、そのパフォーマンスに関する技術です。
- Next.jsの描画速度の比較 (SSR, SSG, ISR, CSR)
- Micro Frontends (マイクロフロントエンド)

### C. データベースとデータストア
データの永続化、検索、そしてパフォーマンスに関する技術です。
- DBのパフォーマンスチューニング (クエリ改善, Index)
- RDBのシャーディング処理
- 検索エンジン技術 (Elasticsearch)
- データストアの多様化 (NoSQL - MongoDB)
- Vector Database (ベクトルデータベース)

### D. システム設計とアーキテクチャ
複数の技術を組み合わせ、堅牢でスケーラブルなシステムを構築するための設計思想です。
- マイクロサービス
- イベント駆動アーキテクチャ (EDA)
- API Gateway
- CQRS & Saga Pattern
- チャットサービスの負荷分散アーキテクチャ
- 動画配信サービスの高トラフィック対応

### E. インフラと運用 (DevOps / SRE)
アプリケーションを動かし、その信頼性を担保するための技術です。
- コンテナ技術 (Docker)
- コンテナオーケストレーション (Kubernetes)
- オブザーバビリティ (Observability)
- CI/CD (継続的インテグレーション/継続的デリバリー)
- Zero Trust Architecture / mTLS

## 2. 実装言語の方針

モダンな開発環境を想定し、以下の言語を主軸とします。

- **Go**: バックエンドの処理、API、並行処理など、パフォーマンスが求められる領域で利用します。
- **TypeScript (Next.js / Node.js)**: フロントエンドの実装、およびフロントエンドと密接に関わるBFF(Backend for Frontend)的な役割で利用します。
- **SQL, YAML, Dockerfileなど**: 特定のツールやミドルウェアを操作するための設定言語・クエリ言語も適宜利用します。

## 3. 各項目の実装プラン

### A. コア・バックエンド技術

| 項目 | 言語 | 実装の流れ | 完成の定義 |
| :--- | :--- | :--- | :--- |
| **Goルーチン** | Go | 1. 複数の処理（例: APIリクエスト、時間のかかる計算）を定義。<br>2. `sync.WaitGroup` と `go` キーワードを使い、これらを並列実行する。 | すべての処理が並列で実行され、完了を待ってからプログラムが正常に終了する。 |
| **メッセージキュー** | Go | 1. **Producer**: メッセージをキューに送信するプログラムを作成。<br>2. **Consumer**: キューからメッセージを受信し、コンソールに表示するプログラムを作成。<br>3. DockerでRabbitMQなどを起動し、両者を接続する。 | Producerで送信したメッセージを、Consumerが非同期で受信・表示できる。 |
| **キャッシュ戦略** | Go | 1. データ取得関数を定義（DBアクセスを模倣し、意図的に遅延させる）。<br>2. Redisに接続し、関数の結果をキャッシュするロジックを実装。<br>3. 2回目以降の呼び出しでは、キャッシュからデータを返すようにする。 | 2回目以降のデータ取得が、1回目より明らかに高速になることを確認できる。 |
| **gRPC** | Go | 1. `.proto` ファイルでサービスとメッセージを定義。<br>2. サーバーとクライアントの雛形コードを生成。<br>3. サーバー側に簡単なロジックを実装。<br>4. クライアントからサーバーを呼び出し、レスポンスを受け取る。 | クライアントがgRPCでサーバーの関数を呼び出し、正しいレスポンスを取得できる。 |
| **GraphQL** | Go | 1. GraphQLのスキーマを定義。<br>2. スキーマに対応するリゾルバ（データ取得ロジック）を実装したGraphQLサーバーを立てる。<br>3. GraphQLのクエリを送信し、必要なデータだけが返却されることを確認する。 | クライアントが指定した構造のクエリで、サーバーから過不足なくデータが返ってくる。 |

### B. フロントエンド技術

| 項目 | 言語 | 実装の流れ | 完成の定義 |
| :--- | :--- | :--- | :--- |
| **Next.js描画比較** | TypeScript | 1. 同じUIを持つページをSSR, SSG, ISR, CSRの4パターンで作成。<br>2. ブラウザのDevToolsで各ページのパフォーマンス（LCP, FCPなど）を計測する。 | 各レンダリング手法の速度や特性の違いを、計測データに基づいて説明できる。 |
| **Micro Frontends** | TypeScript | 1. ヘッダー部分とボディ部分を、それぞれ別のNext.jsアプリとして開発。<br>2. Next.jsの機能やModule Federationを使い、1つのページに統合して表示する。 | 2つの独立したアプリケーションが、1つの画面（`localhost:3000` など）でシームレスに表示・動作する。 |

### C. データベースとデータストア

| 項目 | 言語 | 実装の流れ | 完成の定義 |
| :--- | :--- | :--- | :--- |
| **DBチューニング** | SQL, Go | 1. スロークエリ（例: N+1問題）を意図的に実装。<br>2. `EXPLAIN` で実行計画を確認。<br>3. クエリの改善やINDEXの追加、ORMの利用法を修正する。 | `EXPLAIN` の結果が改善され、アプリケーションのレスポンスタイムが短縮される。 |
| **RDBシャーディング** | Go | 1. ユーザーIDなどのシャーディングキーを元に、接続先のDB（の接続情報）を決定するロジックを実装する。<br>2. 実際に複数DBを立てずとも、ID `1` は `db_1`、ID `1001` は `db_2` といった振り分けができることを確認する。 | 与えられたキーに応じて、正しいシャード（接続先情報）が選択される。 |
| **検索エンジン** | Go | 1. DockerでElasticsearchを起動。<br>2. いくつかのドキュメントをインデックス（登録）するプログラムを作成。<br>3. 登録したドキュメントをキーワードで検索するプログラムを作成する。 | 特定のキーワードで検索APIを叩くと、意図したドキュメントがヒットする。 |
| **NoSQL** | Go | 1. DockerでMongoDBを起動。<br>2. JSON形式のドキュメントを登録・取得・更新・削除する、基本的なCRUD処理を実装する。 | RDBとは異なる、柔軟なスキーマを持つドキュメントの操作ができる。 |
| **Vector Database** | Python/Go | 1. 事前に用意したテキストや画像をベクトル化する（ライブラリ利用）。<br>2. PineconeやMilvusなどのDBにベクトルを登録。<br>3. あるベクトルと「似ている」ベクトルを検索する。 | 入力したデータと類似度の高いデータが、検索結果の上位に表示される。 |

### D. システム設計とアーキテクチャ
これらの項目は、コードだけでなく**構成図**を描き、**Docker Compose**で最小限の環境を構築することがゴールになります。

| 項目 | 言語 | 実装の流れ | 完成の定義 |
| :--- | :--- | :--- | :--- |
| **マイクロサービス** | Go | 1. **A.gRPC** の知識を使い、「ユーザーサービス」と「商品サービス」を作成。<br>2. 2つのサービスをgRPCで呼び出す「注文サービス」を作成。<br>3. 3つのサービスをDocker Composeで連携起動させる。 | 注文サービスへの1リクエストで、他2サービスが連携して動作し、正しいレスポンスが返る。 |
| **EDA** | Go | 1. **A.メッセージキュー**の知識を応用。<br>2. 「注文サービス」は「注文作成イベント」をキューに送信するだけ。<br>3. 「通知サービス」「在庫サービス」がイベントを受信し、それぞれの処理を実行する。 | 注文サービスは即座にレスポンスを返し、後続処理が非同期で実行されることを確認できる。 |
| **API Gateway** | (設定) | 1. KongやTykなどのOSS API GatewayをDockerで起動。<br>2. 複数のバックエンドサービスへのルーティング、認証、レートリミットなどの設定を行う。 | Gatewayの単一エンドポイントを通じて、各バックエンドサービスへ正しくリクエストが振り分けられる。 |
| **CQRS & Saga** | Go | 1. 書き込み（Command）用のAPIと、読み取り（Query）用のAPIを分離して実装。<br>2. （Saga）マイクロサービス環境で、一連の処理が失敗した際に、補償トランザクション（処理の取り消し）が実行されるロジックを実装する。 | 書き込み処理と読み取り処理で、参照するデータモデルやDBが分離されている。Sagaでは、処理失敗時に補償イベントが発行される。 |

### E. インフラと運用 (DevOps / SRE)
これらはコードを書くよりも、ツールの設定ファイル作成やコマンド操作がメインになります。

| 項目 | 言語 | 実装の流れ | 完成の定義 |
| :--- | :--- | :--- | :--- |
| **コンテナ技術** | Dockerfile | 1. 作成したGoのWebアプリケーションのDockerfileを作成する。<br>2. `docker build` でイメージをビルドし、`docker run` でコンテナとして起動する。 | コンテナ化されたアプリケーションに、ブラウザやcurlでアクセスできる。 |
| **K8s** | YAML | 1. 上記コンテナをKubernetes上で動かすためのマニフェストファイル（Deployment, Service）を作成。<br>2. MinikubeなどのローカルK8s環境に `kubectl apply` でデプロイする。 | K8sクラスタ経由でアプリケーションにアクセスできる。 |
| **オブザーバビリティ** | Go, YAML | 1. アプリにPrometheusクライアントを導入し、カスタムメトリクス（例: APIコール数）を公開。<br>2. Prometheusでメトリクスを収集し、Grafanaでグラフ化する。 | Grafanaのダッシュボードで、アプリケーションのメトリクスがリアルタイムに表示される。 |
| **CI/CD** | YAML | 1. GitHub Actionsなどを利用。<br>2. ソースコードがpushされたら、自動でテスト→Dockerイメージのビルド→Docker Hubなどへのpush、が行われるワークフローを定義する。 | GitHubにpushすると、一連のプロセスが自動で実行され、新しいコンテナイメージが作成される。 |
